# os-deep-dive

<details>
<summary>핵심은 변하지 않는다</summary>
하드웨어는 급속도로 발전하고 소프트웨어도 새로운 버전이 등장하지만 컴퓨터 분야의 기본 원리와 정보기술이 추구하는 핵심 철학은 시대가 흘러도 변하지 않는다.

1937년의 수학자 앨런튜링이 개발한 이록적 컴퓨터가 현대 최첨단 컴퓨터가 풀 수 있는 모든 문제를 풀 수 있다는 사실이 증명되었다.

연역법은 컴퓨터의 이론적 기원이다.
</details>
<details>
<summary>컴퓨터와 프로그래밍의 역사</summary>

* 이론적 컴퓨터 - 앨런 튜링(1930년대)
* 기계식 컴퓨터
  * 찰스 배비지
  * 1823년 반복적인 연산을 수행하는 미분기계
  * 19세기 해석기관(천공카드로 20자리까지의 연산을 수행하며 입출력, 처리, 저장 장치를 포함)
* 전자식 컴퓨터
  * 1943년 콜로서스(군사용 암호를 해독하기 위한 컴퓨터)
  * 1944년 Mark I(둘레 16미터, 높이 2.5미터지만 현대의 휴대용 전자계산기보다 느림)
  * ENIAC(18,000여 개의 진공관, 무게 30톤, 7분에 한 번씩 오류, 현대의 휴대용 전자계산기 정도)
    * 최초의 현대식 컴퓨터로 인식
* 근대적 컴퓨터
  * 1세대 컴퓨터 : 진공관 기반(1940년대)
  * 2세대 컴퓨터 : 트랜지스터 기반(1950년대)
  * 3세대 컴퓨터 : 집적회로 기반(1960년대)
  * 4세대 컴퓨터 : 고밀도 집적회로 기반(1970년대)

컴퓨터의 사용이 확산됨에 따라 프로그래밍이 필요해졌다. 기계어의 불편함 때문에 어셈블리어(1950년대 후반)가 등장했고, 문제 자체에 더 가까운 언어가 필요하다고 생각되어 고급 언어인 포트란이 생겼다.

1960년대에는 소프트웨어의 규모가 커짐에따라 인간이 이해하기 쉬운 작은 단위들로 나누어 각 단위를 독립적으로 프로그래밍 하는 **구조적 프로그래밍**이 기법이 대두되었다.
이 시기에 운영체제가 개발되었다. 초창기에는 하드웨어 자체를 관리하는 일과 프로그램을 작성하는 일을 사용자가 다 해야했다. 초기에는 컴퓨터 외부에서 미리 예약하는 일괄처리 방식을 사용하다가, 컴퓨터가 자동으로 처리해주도록 하는 방식을 고민한 결과 운영체제가 탄생했다. 은행 업무 전산화를 위해 DBMS가 등장했다.

1970년대 이후 하드웨어의 발전으로 PC가 등장하고, C 언어(1972년)가 개발되었다. 

1980년대 이후에는 프로그래밍적으로 고품질 소프트웨어를 개발하는 도구로써의 객체지향 언어가 성공했다.

1990년대  초반부터는 윈도우, 월드와이드웹(WWW), Java가 출연했다.
</details>

<details>
<summary>운영체제란</summary>

운영체제는 컴퓨터 하드웨어 바로 윗단에 설치되는 소프트웨어를 말한다. 컴퓨터의 전원을 켜면 운영체제는 이와 동시에 실행된다. 소프트웨어는 실행되기 위해 메모리에 프로그램이 올라가있어야 하는데, 운영체제 자체도 하나의 소프트웨어로서 전원과 동시에 메모리에 올라간다. 하지만,
운영체제와 같이 큰 규모의 프로그램이 모두 메모리에 올라가면 낭비가 심하여 항상 필요한 부분만이 메모리에 올라가는데, 상주하는 운영체제의 부분을 **커널** 이라고 하고 이를 좁은 의미의 운영체제라고도 한다.

운영체제는 하드웨어를 위한 역할과 사용자를 위한 역할을 수행한다. 컴퓨터 시스템 내의 자원을 효율적으로 관리하고 사용자가 사용할 수 있는 환경을 제공하는 것이다.
</details>

<details>
<summary>CPU와 메모리는 공유된다</summary>

CPU가 하나라여서 매 순간 하나의 프로그램만 CPU에서 실행되더라도 짧은 시간의 규모로 여러 프로그램들이 CPU에서 번갈아 실행되고 이를 시분할 시스템이라고 부른다.

메모리는 여러 프로그램이 조금씩 메모리 공간을 보유하며 동시에 메모리에 올라갈 수 있다. 이를 다중 프로그래밍 시스템이라고 부른다.
</details>

<details>
<summary>자원 관리</summary>

하드웨어 자원은 CPU와 메모리를 비롯해 주변장치(입출력 장치)들로 구성된다. CPU와 메모리는 전원이 꺼지면 모두 지워지기 때문에 기억해야 하는 부분을 IO Device 중 하나인 보조기억장치에 파일 형태로 저장한다.

CPU는 여러 프로세스가 동시에 수행될 수 있으므로 효율적이고 공평하게, 특정 프로세스가 불이익을 당하지 않도록 관리한다. FCFS, Round Robin, Priority 등의 방법이 있다.

메모리는 CPU가 직접 접근할 수 있는 컴퓨터 내부의 기억장치인데, 메모리의 어느 부분이 어떤 프로그램에 의해 사용되는지 파악해서 유지하는데 필요한 정보를 주소라고 부른다. 고정분할, 가변분할, 가상메모리 방식이 있다. 특히 가상메모리 방식은 가장 널리 사용되는 메모리 관리 기법인데, 물리 메모리 주소와 매핑하여 사용하는 방식을 사용한다. 
현재 사용되고 있는 부분만 메모리에 올리고, 나머지는 하드디스크와 같은 보조기억 장치에 저장해두었다가 필요할 때 적재하는데 이때 보조장치의 영역을 **스왑 영역** 이라 한다.
</details>

<details>
<summary>로컬버퍼</summary>

입출력 장치의 컨트롤러는 장치로부터 오고 나가는 데이터를 임시로 저장하기 위한 작은 메모리를 가지고 있는데 이것이 로컬버퍼다. 디스크나 키보드 등에서 데이터를 읽어올 때 로컬버퍼에 데이터가 임시로 저장된 후 메모리에 전달된다. 장치에서 로컬버퍼로 읽어오는 일은 컨트롤러가 담당한다.

**프로그램 실행 중 디스크에서 데이터 읽기 명령 > 디스크 컨트롤러가 물리 영역에서 읽어 로컬버퍼 저장 > 완료 시 컨트롤러가 인터럽트를 발생시켜 보고 > CPU 옆 인터럽트 라인에 신호 발생 > CPU가 먼저 처리**
</details>

<details>
<summary>인터럽트</summary>
A라는 프로그램이 CPU를 할당받고 명령을 수행하는 도중 인터럽트가 발생하면 A는 현재 수행 중인 명령의 위치를 저장하고 운영체제 내부 코드인 인터럽트 처리루틴으로 넘어가서 인터럽트 처리를 하고 다시 돌아와 A의 이전 작업 지점부터 수행을 계속 이어간다.

이때 필요한 복귀 주소를 Stack 영역에 보관한다.

인터럽트 때문에 CPU를 빼앗긴 위치는 운영체제가 관리하는 프로세스 제어블록에 저장된다.

인터럽트 발생 시 해주어야 할 작업을 정의한 프로그램 코드인 인터럽트 코드는 운영체제마다 다르다. 주변 장치들은 장치를 관리하기 위해(그 중 하나로 인터럽트를 발생시키기 위해) 작은 CPU를 가지고 있고 이를 컨트롤러라고 부른다.
컨트롤러가 CPU에게 인터럽트를 알리면 CPU는 현재 수행중인 작업을 저장하고 운영체제 내의 키보드 인터럽트 처리루틴을 찾아간다. 처리루틴은 입력받은 내용을 메모리의 특정 부분에 저장하고 해당 프로그램의 입력을 알리면서 인터럽트를 완료한다.

</details>

<details>
<summary>소프트웨어 인터럽트</summary>
트랩(trap)이라는 용어로 불리는 소프트웨어 인터럽트는 예외상황(Exception)과 시스템 콜(System Call)이 있다. 예외상황은 흔히 프로그래밍 언어에서 Exception 이 터졌을 때 처리를 위해 발생시키는 인터럽트이고, 시스템 콜은 프로그램이 운영체제 내부에 정의된 코드를 실행하고 싶을 때 운영체제에 서비스를 요청하는 방법이다. 예를 들어 개발자가 개발 중 I/O 작업이 필요할 경우 직접 입출력을 수행하는 코드를 작성하는 것이 아니라 존재하는 커널의 코드를 호출하는 것이다.

</details>

<details>
<summary>프로그램 구조</summary>
컴퓨터 프로그램은 언어와 상관 없이 함수들로 구성된다. 하나의 함수가 수행되는 중에 다른 함수를 호출하고, 호출된 함수의 수행이 끝나면 다시 원래 위치로 돌아간다.

프로그램이 CPU에서 명령을 수행하려면 해당 명령은 담은 프로그램의 주소 영역이 메모리에 올라가 있어야 한다. 주소 영역은 Code, Data, Stack 영역으로 구분된다.

Code 영역은 작성한 프로그램 함수들의 코드가 CPU에서 수행할 수 있는 기계어 명령 형태로 변환되어 저장되어있는 부분이다.

Data 영역은 전역 변수 등 프로그램이 사용하는 데이터를 저장하는 부분이다.

Stack 영역은 함수가 호출될 때 호출된 함수의 수행을 마치고 복귀할 주소 및 데이터를 임시로 저장하는 데 사용되는 공간이다. 프로그램은 메인함수에서 시작해 다른 함수를 호출하면 CPU가 메인함수의 코드를 수행하다가 다른 함수의 코드로 수행위치를 옮기는데, 이때 돌아와야 하는 지점을 Stack 영역에 저장한다.
</details>

<details>
<summary>시스템의 작동 개요</summary>
CPU는 인간의 뇌처럼 스스로 생각하고 판단할 수 없다. CPU는 빠른 속도로 처리하는 계산 능력을 가지고, 매 시점 메모리의 특정 주소에 존재하는 명령을 하나씩 읽어와 그대로 실행한다.

이때 CPU가 수행해야 할 메모리 주소를 담고 있는 레지스터를 프로그램 카운터라고 부른다.

일반적으로 조건문, 반복문, 함수호출 등에 의한 주소 이동이 없는 이상 프로그램 카운터는 항상 바로 다음 명령을 가리키게 되어 코드의 순차적인 수행이 일워진다.
</details>

출처. 
* 운영체제와 정보기술의 원리, 반효경